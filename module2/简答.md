一、

执行结果是10
因为变量i全局共用， 在for循环执行退出后i已经变成了10

二、
报错：reference error: tmp is not defined
因为if块内有let声明的变量， 所以不会采用全局变量， 但是tmp是在声明之前使用的，存在暂时性死区

三、
Math.min.apply(null, arr)

四：
var 是es6之前声明变量的方式，采用的是函数作用域的方式，有以下特点：
1. 全局声明的var变量会挂在window或者global上
2. 存在变量提升
3. 采用函数作用域

let和const是es6提供的声明变量的方式， 采用的是块级作用域， 特点如下：
1. let和const声明的变量不会挂在window或global
2. 没有变量提升，同一个块内， 变量在声明前不能使用
3. 采用块级作用域

let和const的区别是const声明的变量在声明之后是无法再次修改的， let可以

五：
20
原因有2点
1.  使用obj.fn调用方法， fn内的this指向obj这个对象
2. 虽然实际执行的代码包含在一个回调函数内， 但这个函数使用的是箭头函数， 其内部的this指向调用环境的this

六：
1.  为变量添加唯一标识符
2.  模拟实现私有成员

七、
浅拷贝： 只复制引用，拷贝后两个变量指向一个地址， 通过一个变量修改内存内的值， 另一个变量也会受影响、
深拷贝： 完全复制， 两个变量内部属性值完全相同， 但是是两个内存空间， 互不影响

八、
ts =  js + es6+ + 类型系统，换句话说, ts时js的超集

九、
ts优点：
1. 有严格的类型系统， 避免方法等有预料外的调用方式
2. 生态完善

ts缺点：
1. 学习成本高
2. 类型声明增加开发成本


十、
1. 记录当前所有变量的引用数
2. 判断引用数是否为0
3.  如果为0， 立即清理， 回收空间、

优点：
1. 能够即时回收垃圾对象
2. 能最大程度减少程序暂停

缺点：
1. 时刻监控对象引用数量， 时间消耗大
2. 无法回收循环引用的变量

十一、
1. 遍历当前所有可达对象
2. 移动对象位置，整理分散的内存空间
3. 清理未被标记的对象

十二、
新生代采用复制算法+标记整理的方式 

1. 把新生代的空间整体等分成From和To两份
2. 当前的可达对象存储在From
3. 对From内的变量进行标记整理， 之后拷贝到To空间
4. From和To空间交换， 然后释放前From空间

十三、
在老生代GC时使用
原理：整体GC分段进行， 让程序和GC交替执行，  优化程序执行效率


